// MATRIZ DE RECOMPENSA/REFORCO

var map = [
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -100],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -100],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -100],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -100],
  [-10, 0, 0, 0, 100, 0, 0, 0, 1000, -10, -10, -10, -10, -10, -10, -10, -10, -10, 0, 0, 0, 0, 0, 0, 0, 0, -100],
  [0, 0, 0, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -100],
  [-10, 100, 1000, 0, 0, 0, 0, 0, 0, -10, -10, -10, -10, -10, -10, -10, -10, -10, 0, 0, 0, 0, 0, 0, 0, 0, -100],
  [-10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -100]
];

// LISTA DE ACOES

var action_list = ['+T1+T2+T3', '+T1+T2-T3', '+T1+T2N3', '+T1-T2+T3', '+T1-T2-T3', '+T1-T2N3', '+T1N2+T3', '+T1N2-T3', '+T1N2N3',
  '-T1+T2+T3', '-T1+T2-T3', '-T1+T2N3', '-T1-T2+T3', '-T1-T2-T3', '-T1-T2N3', '-T1N2+T3', '-T1N2-T3', '-T1N2N3',
  'N1+T2+T3', 'N1+T2-T3', 'N1+T2N3', 'N1-T2+T3', 'N1-T2-T3', 'N1-T2N3', 'N1N2+T3', 'N1N2-T3', 'N1N2N3'];

var sarsaConstructor = require("./index.js")

var defaultSettings = {
  'alpha': 0.2,              // Taxa de aprendizagem (alpha)
  'gamma': 0.8,               // Fator de desconto (gamma)
  'defaultReward': 0,       // Recompensa padrão dada aos pares de estado/acao nao inicializados
  'epsilon': 0.02,            // Taxa de aleatoriedade que constitui fator exploratorio junto com b1b2b3i e T1T2T3i
  'policy': 'epsilonGreedy'   // Política
}

var sarsa = sarsaConstructor(defaultSettings)

// IMPORTACAO DOS MODULOS DO PSIOT

var psiot_novo_estado = require("./psiot_modules/calcula_novo_estado") // Calcula o novo estado dos buffers e das taxas de transmissao
var psiot_soma = require("./psiot_modules/soma.js") // Soma os elementos de um array
var psiot_maior_que_limite = require("./psiot_modules/maior_que_limite.js") // Verifica se buffer atingiu limite 
// que determina o estado CHEIO/FULL/ABOVE LIMIT (C/F/AL) ou VAZIO/EMPTY/BELLOW LIMIT (V/E/BL)
var psiot_maior_que_buffer = require("./psiot_modules/maior_que_buffer.js") // Verifica se buffer "estourou", caso positivo iniciam as perdas de pacotes
var psiot_maior_que_banda = require("./psiot_modules/maior_que_banda.js") // Verifica se largura de banda foi superada
var psiot_conversor = require("./psiot_modules/conversor")

// PARAMETROS DE ENTRADA PADRAO

var limite = 50; // Limite estabelecido para considerar buffer CHEIO/FULL/ABOVE LIMIT (C/F/AL) ou VAZIO/EMPTY/BELLOW LIMIT (V/E/BL)
module.exports = limite; // Exporta a variável "limite" para o modulo "maior_que_limite.js" do PSIoT
var tam_buffers = 100; // Tamanho dos buffers
var lb = 100; // Limite de Largura de banda 
var action = 'N1N2N3'; // Acao default
var trials_max = 500; // Quantidade maxima de tentativas

// FATORES E NIVEIS EXPLORATORIOS

var b1b2b3_inicial = [120, 80, 80];
var b1b2b3_inicial_dsc = b1b2b3_inicial.map(psiot_maior_que_limite); // Discretizacao dos buffers / Ex: transforma [70,60,20] em [1,1,0]
var b1b2b3_inicial_dsc_alfa = b1b2b3_inicial_dsc.map(psiot_conversor); // Discretizacao dos buffers / Ex: transforma [1,1,0] em [C,C,V]
var b1b2b3i = [120, 80, 80];
var b1b2b3i_dsc = b1b2b3i.map(psiot_maior_que_limite); // Discretizacao dos buffers / Ex: transforma [70,60,20] em [1,1,0]

var T1T2T3_inicial = [15, 25, 35];
var T1T2T3i = [15, 25, 35];
var bandwidth_inicial = psiot_soma(T1T2T3_inicial) // Total de ocupacao da banda inicial

var tot_P1 = 0; // Total de perda de pacotes do buffer 1
var tot_P2 = 0; // Total de perda de pacotes do buffer 2 
var tot_P3 = 0; // Total de perda de pacotes do buffer 3

// Imprime na tela os titulos do relatorio (Numero da tentativa, b1b2b3i, acao, recompensa, b1b2b3, proxima acao,
// T1T2T3, situacao lb, perdas acumuladas P1 P2 P3)

console.log('trial', '|', 'state0', '|', 'action0', '|', 'reward', '|', 'state1', '|',
  'action1', '|', 'T1T2T3', '|', '> largura de banda?', '|', 'tot_P1', '|', 'tot_P2', '|', 'tot_P3');

for (var trials = 1; trials <= trials_max; trials++) {

  // Representa novo estado de buffers, novo estado das taxas de transmissao e 
  // coluna da matriz recompensa que corresponde a nova acao

  var novo_estado = psiot_novo_estado(b1b2b3i, action, T1T2T3i);

  // VARIAVEIS DE INTERESSE - BUFFERS

  // Novo estado dos buffers

  var b1b2b3 = [Math.round(novo_estado.a), Math.round(novo_estado.b), Math.round(novo_estado.c)];

  // Discretizacao dos buffers 

  var b1b2b3_dsc = b1b2b3.map(psiot_maior_que_limite); // Ex: transforma [70,60,20] em [1,1,0]
  var b1b2b3_dsc_alfa = b1b2b3_dsc.map(psiot_conversor); // Ex: transforma [1,1,0] em [C,C,V]

  // Descobre a linha da matriz de recompensa do novo estado do buffer

  var b1b2b3_bin = parseInt(b1b2b3_dsc.join(''), 2);

  // VARIAVEIS DE INTERESSE - TAXAS DE TRANSMISSAO

  // Novo estado das taxas de transmissao

  var T1T2T3 = [Math.round(novo_estado.t), Math.round(novo_estado.r), Math.round(novo_estado.s)];

  // Total de ocupacao da banda

  var bandwidth = psiot_soma(T1T2T3);

  // Se a largura de banda estiver superada armazena 'true', caso contrario armazena a ocupacao da banda no momento

  var T1T2T3_dsc = psiot_maior_que_banda(lb, T1T2T3);

  // Representam o percentual de aumento/diminuicao da taxa de transmissao inicial (T1T2T3i) para atingir o objetivo

  var ft1 = Math.round([(T1T2T3[0] / T1T2T3_inicial[0]) - 1] * 100);
  var ft2 = Math.round([(T1T2T3[1] / T1T2T3_inicial[1]) - 1] * 100);
  var ft3 = Math.round([(T1T2T3[2] / T1T2T3_inicial[2]) - 1] * 100);

  // VARIAVEIS DE INTERESSE - PERDA DE PACOTES

  // Calcula a perda de pacotes por buffer

  if (psiot_maior_que_buffer(b1b2b3[0], tam_buffers) === true) {
    var P1 = b1b2b3[0] - tam_buffers;
    tot_P1 = tot_P1 + P1;
  } else { P1 = 0 };

  if (psiot_maior_que_buffer(b1b2b3[1], tam_buffers) === true) {
    var P2 = b1b2b3[1] - tam_buffers;
    tot_P2 = tot_P2 + P2;
  } else { P2 = 0 };

  if (psiot_maior_que_buffer(b1b2b3[2], tam_buffers) === true) {
    var P3 = b1b2b3[2] - tam_buffers;
    tot_P3 = tot_P3 + P3;
  } else { P3 = 0 };

  // ACAO

  var new_action = sarsa.chooseAction(b1b2b3_dsc, action_list);  // Seleciona a nova acao

  // RECOMPENSA

  if (T1T2T3_dsc === true) {

    reward = -13000; // Caso haja superacao da largura de banda, imputa-se uma punicao alta 

  } else { reward = map[b1b2b3_bin][novo_estado.j] }; // Descobre a recompensa baseado na linha (novo estado do buffer) e 
  // na coluna "j" (acao geradora do novo estado) da matriz "map"  

  // Atualiza a Q-Table

  sarsa.update(b1b2b3i_dsc, action, reward, b1b2b3_dsc, new_action);

  // Imprime na tela os dados do relatorio

  console.log(trials, b1b2b3i, action, reward, b1b2b3, new_action, T1T2T3, T1T2T3_dsc, tot_P1, tot_P2, tot_P3);

  // Atualiza as variaveis iniciais para o novo ciclo

  b1b2b3i = b1b2b3;
  b1b2b3i_dsc = b1b2b3_dsc;
  action = new_action;
  T1T2T3i = T1T2T3;

  // Verifica se o objetivo especifico foi atingido

  if (bandwidth > 95 && bandwidth <= 100 && novo_estado.a <= 50 && novo_estado.b <= 50) { // Objetivo especifico

    console.log("----------------------------------------------------------------------------------------------------------");
    console.log('\x1b[34m%s\x1b[0m', "SOLUÇÃO:");
    console.log("O PSIOT-SARSA atingiu o objetivo com", trials, "tentativas!");
    console.log("Estado inicial dos buffers:", b1b2b3_inicial, b1b2b3_inicial_dsc_alfa);
    console.log('\x1b[31m%s\x1b[0m', "Estado final dos buffers:", b1b2b3, b1b2b3_dsc_alfa);
    console.log("Estado inicial das taxas de transmissão:", T1T2T3_inicial);
    console.log('\x1b[31m%s\x1b[0m', "Estado final das taxas de transmissão:", T1T2T3);
    console.log('\x1b[31m%s\x1b[0m', "Aumento/diminuição das taxas de transmissão por buffer:", "b1=", ft1, "%", "b2=", ft2, "%", "b3=", ft3, "%");
    console.log("Alocação de banda inicial:", bandwidth_inicial, "%");
    console.log('\x1b[31m%s\x1b[0m', "Alocação de banda final:", bandwidth, "%");
    console.log('\x1b[31m%s\x1b[0m', "Total de perda de pacotes por buffer:", "b1=", tot_P1, "b2=", tot_P2, "b3=", tot_P3);
    break;

  }

}

if (trials > trials_max) {
  console.log("----------------------------------------------------------------------------------------------------------");
  console.log('\x1b[31m%s\x1b[0m', "SOLUÇÃO NÃO ENCONTRADA! LIMITE DE TENTATIVAS ALCANÇADO!");
}