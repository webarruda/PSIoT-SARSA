// Matriz de recompensa/reforco
  var map = [ 
    [0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 1, 1, 1],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 1, 1, 1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0],
    [0, 0, 0, 1, 1, 1, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 0, 0, 1, 1, 1, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 0, 0, 1, 1, 1, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 0, 0, 1, 1, 1, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
   ];

// Lista de acoes
var action_list = ['+T1+T2+T3','+T1+T2-T3','+T1+T2N3','+T1-T2+T3','+T1-T2-T3','+T1-T2N3','+T1N2+T3','+T1N2-T3','+T1N2N3',

'-T1+T2+T3','-T1+T2-T3','-T1+T2N3','-T1-T2+T3','-T1-T2-T3','-T1-T2N3','-T1N2+T3','-T1N2-T3','-T1N2N3',

'N1+T2+T3','N1+T2-T3','N1+T2N3','N1-T2+T3','N1-T2-T3','N1-T2N3','N1N2+T3','N1N2-T3','N1N2N3'];

var sarsaConstructor = require("../index.js")

var defaultSettings = {
  'alpha':0.2,              // Taxa de aprendizagem (alpha)
  'gamma':0.8,               // Fator de desconto (gamma)
  'defaultReward' : 0,       // Recompensa padrão dada aos pares de estado/acao nao inicializados
  'epsilon':0.16,            // Taxa de aleatoriedade constitui fator exploratorio junto com b1b2b3i e T1T2T3i
 // 'policy':'epsilonGreedy'   // Política
  'policy':'softmax'
}

var sarsa = sarsaConstructor(defaultSettings)

// Fatores e niveis exploratorios
var b1b2b3i = [70, 40, 40]; // CVV
var T1T2T3i = [35, 25, 15]; // T1 > T2 > T3

// Parametros de entrada padrao
var limite = 50; // Limite estabelecido para considerar buffer VAZIO ou CHEIO
var tam_buffers = 80; // Tamanho dos buffers
var lb = 100; // Largura de banda
var action = 'N1N2N3'; // Acao default

// Variaveis de interesse
var tot_P1 = 0; // Total de perda de pacotes do b1
var tot_P2 = 0; // Total de perda de pacotes do b2 
var tot_P3 = 0; // Total de perda de pacotes do b3 

// Outras inicializacoes de variaveis
var trials_max = 500*1000; // Quantidade maxima de tentativas
var j = null; // Numero da coluna na matriz de recompensa
var b1b2b3i_dsc = b1b2b3i.map(maiorquelimite);
var sum = 100;

// Calcula o novo estado
function calcula_novo_estado(x,y,z){
    switch(y)
    { 
          case '+T1+T2+T3':
          return {'a': x[0]*0.9, 'b': x[1]*0.9, 'c': x[2]*0.9, 'j':0, 't': z[0]*1.1, 'r': z[1]*1.1, 's': z[2]*1.1};
          break; 
          
          case '+T1+T2-T3':
          return {'a': x[0]*0.9, 'b': x[1]*0.9, 'c': x[2]*1.1, 'j':1, 't': z[0]*1.1, 'r': z[1]*1.1, 's': z[2]*0.9};
          break;            

          case '+T1+T2N3':
          return {'a': x[0]*0.9, 'b': x[1]*0.9, 'c': x[2], 'j':2, 't': z[0]*1.1, 'r': z[1]*1.1, 's': z[2]};
          break; 

          case '+T1-T2+T3':
          return {'a': x[0]*0.9, 'b': x[1]*1.1, 'c': x[2]*0.9, 'j':3, 't': z[0]*1.1, 'r': z[1]*0.9, 's': z[2]*1.1};
          break; 

          case '+T1-T2-T3':
          return {'a': x[0]*0.9, 'b': x[1]*1.1, 'c': x[2]*1.1, 'j':4, 't': z[0]*1.1, 'r': z[1]*0.9, 's': z[2]*0.9};
          break; 

          case '+T1-T2N3':
          return {'a': x[0]*0.9, 'b': x[1]*1.1, 'c': x[2], 'j':5, 't': z[0]*1.1, 'r': z[1]*0.9, 's': z[2]};
          break; 

          case '+T1N2+T3':
          return {'a': x[0]*0.9, 'b': x[1], 'c': x[2]*0.9, 'j':6, 't': z[0]*1.1, 'r': z[1], 's': z[2]*1.1};
          break; 

          case '+T1N2-T3':
          return {'a': x[0]*0.9, 'b': x[1], 'c': x[2]*1.1, 'j':7, 't': z[0]*1.1, 'r': z[1], 's': z[2]*0.9};
          break; 

          case '+T1N2N3':
          return {'a': x[0]*0.9, 'b': x[1], 'c': x[2], 'j':8, 't': z[0]*1.1, 'r': z[1], 's': z[2]};
          break; 

          case '-T1+T2+T3':
          return {'a': x[0]*1.1, 'b': x[1]*0.9, 'c': x[2]*0.9, 'j':9, 't': z[0]*0.9, 'r': z[1]*1.1, 's': z[2]*1.1};
          break; 

          case '-T1+T2-T3':
          return {'a': x[0]*1.1, 'b': x[1]*0.9, 'c': x[2]*1.1, 'j':10, 't': z[0]*0.9, 'r': z[1]*1.1, 's': z[2]*0.9};
          break; 

          case '-T1+T2N3':
          return {'a': x[0]*1.1, 'b': x[1]*0.9, 'c': x[2], 'j':11, 't': z[0]*0.9, 'r': z[1]*1.1, 's': z[2]};
          break; 

          case '-T1-T2+T3':
          return {'a': x[0]*1.1, 'b': x[1]*1.1, 'c': x[2]*0.9, 'j':12, 't': z[0]*0.9, 'r': z[1]*0.9, 's': z[2]*1.1};
          break; 

          case '-T1-T2-T3':
          return {'a': x[0]*1.1, 'b': x[1]*1.1, 'c': x[2]*1.1, 'j':13, 't': z[0]*0.9, 'r': z[1]*0.9, 's': z[2]*0.9};
          break; 

          case '-T1-T2N3':
          return {'a': x[0]*1.1, 'b': x[1]*1.1, 'c': x[2], 'j':14, 't': z[0]*0.9, 'r': z[1]*0.91, 's': z[2]};
          break; 

          case '-T1N2+T3':
          return {'a': x[0]*1.1, 'b': x[1], 'c': x[2]*0.9, 'j':15, 't': z[0]*0.9, 'r': z[1], 's': z[2]*1.1};
          break; 

          case '-T1N2-T3':
          return {'a': x[0]*1.1, 'b': x[1], 'c': x[2]*1.1, 'j':16, 't': z[0]*0.9, 'r': z[1]*1.1, 's': z[2]*0.9};
          break; 

          case '-T1N2N3':
          return {'a': x[0]*1.1, 'b': x[1], 'c': x[2], 'j':17, 't': z[0]*0.9, 'r': z[1], 's': z[2]};
          break; 

          case 'N1+T2+T3':
          return {'a': x[0], 'b': x[1]*0.9, 'c': x[2]*0.9, 'j':18, 't': z[0], 'r': z[1]*1.1, 's': z[2]*1.1};
          break; 

          case 'N1+T2-T3':
          return {'a': x[0], 'b': x[1]*0.9, 'c': x[2]*1.1, 'j':19, 't': z[0], 'r': z[1]*1.1, 's': z[2]*0.9};
          break; 

          case 'N1+T2N3':
          return {'a': x[0], 'b': x[1]*0.9, 'c': x[2], 'j':20, 't': z[0], 'r': z[1]*1.1, 's': z[2]};
          break; 

          case 'N1-T2+T3':
          return {'a': x[0], 'b': x[1]*1.1, 'c': x[2]*0.9, 'j':21, 't': z[0], 'r': z[1]*0.9, 's': z[2]*1.1};
          break; 

          case 'N1-T2-T3':
          return {'a': x[0], 'b': x[1]*1.1, 'c': x[2]*1.1, 'j':22, 't': z[0], 'r': z[1]*0.9, 's': z[2]*0.9};
          break; 

          case 'N1-T2N3':
          return {'a': x[0], 'b': x[1]*1.1, 'c': x[2], 'j':23, 't': z[0], 'r': z[1]*0.9, 's': z[2]};
          break; 

          case 'N1N2+T3':
          return {'a': x[0], 'b': x[1], 'c': x[2]*0.9, 'j':24, 't': z[0], 'r': z[1], 's': z[2]*1.1};
          break; 

          case 'N1N2-T3':
          return {'a': x[0], 'b': x[1], 'c': x[2]*1.1, 'j':25, 't': z[0], 'r': z[1], 's': z[2]*0.9};
          break; 

          case 'N1N2N3':
          return {'a': x[0], 'b': x[1], 'c': x[2], 'j':26, 't': z[0], 'r': z[1], 's': z[2]};
          break;        
    }
}

// Imprime na tela os titulos (Numero da tentativa, b1b2b3i, acao, recompensa, b1b2b3, proxima acao,
// T1T2T3, situacao lb, perdas acumuladas P1 P2 P3)
console.log('trial','|','state0', '|','action0', '|', 'reward', '|','state1','|',
'action1', '|','T1T2T3', '|','> lb?',  '|','tot_P1', '|','tot_P2', '|','tot_P3');

for (var trials=1; trials<=trials_max; trials++) {

// Representa novo estado de buffers, novo estado das taxas de transmissao e 
// coluna da matriz recompensa que corresponde a nova acao
  var novo_estado = calcula_novo_estado(b1b2b3i,action,T1T2T3i); 

  var b1 = Math.round(novo_estado.a);
  var b2 = Math.round(novo_estado.b);
  var b3 = Math.round(novo_estado.c);

  var b1b2b3 = [b1,b2,b3]; // Novo estado dos buffers    
    
// Calcula perda de pacotes por buffer
  if(maiorquebuffer(b1)===true){
      var P1 = b1-tam_buffers; 
      tot_P1 = tot_P1 + P1;      
  } else {P1 = 0};
  
  if(maiorquebuffer(b2)===true){
    var P2 = b2-tam_buffers; 
    tot_P2 = tot_P2 + P2;  
  } else   {P2 = 0};

  if(maiorquebuffer(b3)===true){
    var P3 = b3-tam_buffers; 
    tot_P3 = tot_P3 + P3;    
  } else   {P3 = 0};
 
 // Discretizacao dos buffers. Ex: transforma [70,60,20] em CCV
  var b1b2b3_dsc = b1b2b3.map(maiorquelimite);

 // Descobre a linha da matriz de recompensa do novo estado do buffer
  var b1b2b3_bin = parseInt(b1b2b3_dsc.join(''),2);

// Novo estado das taxas de transmissao
  var T1T2T3 = [Math.round(novo_estado.t),Math.round(novo_estado.r),Math.round(novo_estado.s)];

// Se a largura de banda estiver superada, armazena 'true', caso contrario a ocupacao da banda no momento
  var T1T2T3_dsc = maiorquebanda(T1T2T3);
 
  var new_action = sarsa.chooseAction(b1b2b3_dsc,action_list); // Seleciona a nova acao

// Descobre a recompensa baseado na Linha (novo estado do buffer) e 
// na coluna (acao geradora do novo estado) da matriz  
  reward = map[b1b2b3_bin][novo_estado.j]; 
 
// Caso haja superacao da largura de banda, imputa-se uma punicao alta 
if(T1T2T3_dsc === true){
    
  reward = -10; 
}

// Atualiza a Q-Table
 sarsa.update(b1b2b3i_dsc,action,reward,b1b2b3_dsc,new_action);

// Imprime na tela o relatorio
 console.log(trials,b1b2b3i,action,reward,b1b2b3,new_action,T1T2T3,T1T2T3_dsc, tot_P1, tot_P2, tot_P3);

   b1b2b3i = b1b2b3;
   b1b2b3i_dsc = b1b2b3_dsc; 
   action = new_action;
   T1T2T3i = T1T2T3;
   sum = T1T2T3_dsc.soma;

// Verifica se o objetivo especifico foi atingido
   if ( sum >= 98 && novo_estado.t > novo_estado.r && novo_estado.r > novo_estado.s )  {
     console.log("Achei!");
     var qtable = sarsa.getRewards(b1b2b3_dsc,action_list);
      console.log(qtable);
     break;       
    }   
}

// Verifica se buffer atingiu limite que determina o estado CHEIO ou VAZIO
function maiorquelimite(x){
    if(x > limite){
        return 1;
    } else {return 0};
}

// Verifica se largura de banda foi superada
function maiorquebanda(x){
    var soma = 0;
    for(i = 0; i < x.length; i++) {
        soma+=Number(x[i]);
    }
        if(soma > lb){
            return true;
       // } return {'soma':soma, 'false':false};
       } return {'soma':soma};
}

// Verifica se buffer "estourou", caso positivo começa ocorrer perda de pacotes
function maiorquebuffer(x){ 
    if(x > tam_buffers){
        return true;
    } else {return false};
}

