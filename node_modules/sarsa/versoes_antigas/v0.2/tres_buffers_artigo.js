// Fatores e niveis exploratorios
var b1b2b3i = [80, 80, 20]; // CVV
var T1T2T3i = [35, 25, 15]; // T1 < T2 < T3
var T1T2T3 = [44, 28, 28];
var fb1 = 2-(T1T2T3[0]/T1T2T3i[0]);
var fb2 = 2-(T1T2T3[1]/T1T2T3i[1]);
var fb3 = 2-(T1T2T3[2]/T1T2T3i[2]);
console.log(fb1.toFixed(2));
console.log(fb2.toFixed(2));
console.log(fb3.toFixed(2));

// Parametros de entrada padrao
var limite = 50; // Limite estabelecido para considerar buffer VAZIO ou CHEIO
var tam_buffers = 100; // Tamanho dos buffers
var lb = 100; // Largura de banda
var action = 'N1N2N3'; // Acao default

// Variaveis de interesse
var tot_P1 = 0; // Total de perda de pacotes do b1
var tot_P2 = 0; // Total de perda de pacotes do b2 
var tot_P3 = 0; // Total de perda de pacotes do b3 

// Calcula o novo estado
function calcula_novo_estado(x,y){
    switch(x)
    { 
        case 0 :
        return {'a': y[0], 'b': y[1], 'c': y[2]};
        break;

         default :
         return {'a': y[0]*fb1.toFixed(1), 'b': y[1]*fb2.toFixed(1), 'c': y[2]*fb3.toFixed(1)};
         break;
             
    }
}

// Discretizacao dos buffers. Ex: transforma [70,60,20] em CCV
var b1b2b3i_dsc = b1b2b3i.map(maiorquelimite);

//console.log(b1b2b3i_dsc);

var b1b2b3i_bin = parseInt(b1b2b3i_dsc.join(''),2);

//console.log(b1b2b3i_bin);

var novo_estado = calcula_novo_estado(b1b2b3i_bin,b1b2b3i); 

var b1 = Math.round(novo_estado.a);
var b2 = Math.round(novo_estado.b);
var b3 = Math.round(novo_estado.c);

var b1b2b3 = [b1,b2,b3]; // Novo estado dos buffers

// Calcula perda de pacotes por buffer
if(maiorquebuffer(b1)===true){
    var P1 = b1-tam_buffers; 
    tot_P1 = tot_P1 + P1;      
} else {P1 = 0};

if(maiorquebuffer(b2)===true){
  var P2 = b2-tam_buffers; 
  tot_P2 = tot_P2 + P2;  
} else   {P2 = 0}; 

if(maiorquebuffer(b3)===true){
  var P3 = b3-tam_buffers; 
  tot_P3 = tot_P3 + P3;    
} else   {P3 = 0};


// Se a largura de banda estiver superada, armazena 'true', caso contrario a ocupacao da banda no momento
var T1T2T3_dsc = maiorquebanda(T1T2T3);


//var T1 = Math.round(novo_estado.t);
//var T2 = Math.round(novo_estado.r);
//var T3 = Math.round(novo_estado.s);

//var T1T2T3 = [T1,T2,T3];


//console.log(b1b2b3);

//console.log(T1T2T3);

//var b1 = b1b2b3i[0];
//var b2 = b1b2b3i[1];
//var b3 = b1b2b3i[2];
//console.log(b1);
//console.log(b2);
//console.log(b3);

// Imprime na tela os titulos (Numero da tentativa, b1b2b3i, acao, recompensa, b1b2b3, proxima acao,
// T1T2T3, situacao lb, perdas acumuladas P1 P2 P3)
console.log('trial', '|', 'state0', '|','action0', '|', 'reward', '|','state1','|',
'action1', '|','T1T2T3', '|','> lb?',  '|','tot_P1', '|','tot_P2', '|','tot_P3');


console.log(1,b1b2b3i,'X','X',b1b2b3,'X',T1T2T3,T1T2T3_dsc, tot_P1, tot_P2, tot_P3);


// Verifica se largura de banda foi superada
function maiorquebanda(x){
    var soma = 0;
    for(i = 0; i < x.length; i++) {
        soma+=Number(x[i]);
    }
        if(soma > lb){
            return true;
       // } return {'soma':soma, 'false':false};
       } return {'soma':soma};
}

// Verifica se buffer "estourou", caso positivo comeÃ§a ocorrer perda de pacotes
function maiorquebuffer(x){ 
    if(x > tam_buffers){
        return true;
    } else {return false};
}

// Verifica se buffer atingiu limite que determina o estado CHEIO ou VAZIO
function maiorquelimite(x){
    if(x > limite){
        return 1;
    } else {return 0};
}
